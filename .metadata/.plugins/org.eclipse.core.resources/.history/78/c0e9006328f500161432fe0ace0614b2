import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class HuffmanASCIIOrder {
      public static void main(String[] args){
       Scanner in = new Scanner(System.in);
       
       while(true){
       String sentence = in.nextLine();
       String binaryString=""; 
       
       
       for(int i=0; i < sentence.length(); i++){       
           int decimalValue = (int)sentence.charAt(i);     
           String binaryValue = Integer.toBinaryString(decimalValue);      
           for(int j=7;j>binaryValue.length();j--){
               binaryString+="0";          
            }
           binaryString += binaryValue+" "; 
       }    
       
              
       int[] array = new int[256];     
       
       for(int i=0; i < sentence.length(); i++){    
           array[(int)sentence.charAt(i)]++;           
       }
       
       
       PriorityQueue < Tree >  PQ = new PriorityQueue < Tree >() ; 
           
       for(int i=0; i<array.length; i++){ 
           if(array[i]>0){            
               Tree myTree = new Tree();    
               myTree.frequency = array[i]; 
               myTree.root=new Node();     
               myTree.root.letter = (char)i;
               myTree.alpha=i;
               PQ.add(myTree);              
            }
        }
        
        
          while(PQ.size()>1){
            Tree firstTree = PQ.poll(); 
            Tree secondTree = PQ.poll();
             
            Tree comboTree = new Tree();   
            
            comboTree.frequency=firstTree.frequency+secondTree.frequency;  
            comboTree.root=new Node();      
            comboTree.root.leftChild=firstTree.root; 
            comboTree.root.rightChild=secondTree.root;
          
            if(firstTree.frequency==secondTree.frequency)
            {
            	if(firstTree.alpha>secondTree.alpha)
            	{
            		comboTree.root.leftChild=secondTree.root;    
            	}
            }
            comboTree.alpha=Math.min(firstTree.alpha,secondTree.alpha);
            
            PQ.add(comboTree); 
        }
        
        Tree HuffmanTree = PQ.poll();   
        int totalLength=0;            
        String theCode;
        for(int i=0; i<sentence.length(); i++){
            theCode=HuffmanTree.getCode(sentence.charAt(i));
            System.out.print(theCode); 
            totalLength+=theCode.length();  
        }
     
        } 
    }      
}
class Tree implements Comparable<Tree>
   {
   public Node root;             
   public int frequency=0;
   public int alpha=0;
    
   public Tree()                 
      {root=null;}            

   public int compareTo(Tree object){
       if(frequency-object.frequency>0){
           return 1;
        }else if(frequency-object.frequency<0){
           return -1;   
        }else{
           if(alpha<object.alpha)
               {return -1;}
           else if(alpha>object.alpha)
               {return 1;}
            else 
            {return 0;}  
        }
   }

   String path="error";
    
   public String getCode(char letter){ 
       inOrder(root, letter, "");   
       return path;    
   }


   private void inOrder(Node localRoot, char letter, String path){
      if(localRoot != null){ 
          if(localRoot.letter==letter){
            this.path=path;    
          }else{
            inOrder(localRoot.leftChild, letter, path+"0"); 
            inOrder(localRoot.rightChild, letter, path+"1");    
         }
      }
      return; 
   }

}
class Node
   {
   
   public char letter='@';           
   public Node leftChild;         
   public Node rightChild;        
}
